## DP(Dynamic Programming)

> 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법

- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함
- 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(탑다운과 보텀업)으로 구성된다
  - 탑다운 = `하향식`
  - 보텀업 = `상향식`

- 다이나믹 프로그래밍은 `동적 계획법`이라고도 부른다
  - 자료구조에서의 동적 할당
    - 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법
  - 다이나믹 프로그래밍
    - '다이나믹'은 별다른 의미 없이 사용된 단어



### 다이나믹 프로그래밍의 조건

1. 최적 부분 구조 (Optimal Substructure)

   - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다

2. 중복되는 부분 문제 (Overlapping Subproblem)

   - 동일한 작은 문제를 반복적으로 해결

   

ex) 피보나치 수열

```python
# 피보나치 함수를 재귀함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```

- 단순 재귀함수로 피보나치 수열을 해결하면 지수 시간 복잡도 `O(2^n)`를 가지게 된다



### 메모이제이션(Memoization)

- 다이나믹 프로그래밍의 구현 방법 중 하나
- 한 번 계산한 결과를 메모리 공간에 메모하는 기법
  - 같은 문제를 다시 호출하면 메모했던 결과 그대로 가져옴
  - 값을 기록해 놓는다는 점에서 캐싱(Caching) 이라고도 한다



### 탑다운 vs 보텀업

- 탑다운(메모이제이션) 방식은 하향식, 보텀업 방식은 상향식
- 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식
  - 결과 저장용 리스트는 `DP 테이블` 이라고 부른다

```python
## 탑다운 방식의 피보나치 수열

# 계산된 결과를 메모이제이션 하기 위한 리스트
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]

    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```

> 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)

```python
## 보텀업 방식의 피보나치 수열

d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
   
print(d[n])
```





